<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 声明变量的问题：导致数据被覆盖
        let声明的变量不允许当前作用域的范围内重复声明，在作用域外不能访问
         变量提升：怪异的数据访问，闭包问题
         不会有变量提升不能在定义前使用他
         全局变量挂载到全局对象:全局对象成员污染问题
         let声明的变量不会挂载到全局对象
         引入let关键词用于解决变量声明的问题，同时引入了块级作用域的概念
         块级作用域：代码执行时遇到花括号，会创建一个块级作用域，花括号，结束，销毁块级作用域
         
         底层实现上，let变量实际上也会有提升，提升后放入暂时性死区，如果访问的变量位于暂时性死区就会报错，
         当代吗运行到声明语句时，会从暂时性死区中移除

         在循环中，用let声明的循环变量会特殊处理，每次进入循环体，都会开启一个新的作用域，再循环结束后会销毁。

         const常量和let一样但是要在声明时就要赋值且不可以改变，声明的内存空间不可以改变，里面的地址是可以改变的，
         命名时，特殊的用全英文大写来表示，可以加下划线，循环不可以使用常量。

         因为函数存在双重用途
         所以就用new.target来判断，如果没有用new来调用函数，就会返回undefined，
         如果使用new来调用函数，就会返回函数本身

         箭头函数是一个函数表达式，理论上任何使用函数表达式的时候都可以使用箭头函数
         （参数一，参数2，参数三）=>{
             函数体
         }当只有一个参数的时候，可以省略小括号
         多数情况下箭头函数是用来解决函数里面嵌套函数的this指向问题

         当返回的值只有一条语句时，可以省略大括号和return关键字
         当返回对象的时候要加上小括号才能识别出

         箭头函数中不存在this，arguments，new.target,如果使用了，则使用的是函数外层对应的
         箭头函数没有原型，不能看做构造函数

         应用场景：
         临时使用的函数，不会刻意的调用他，
         1.事件处理函数
         2。异步处理函数 settimeout
         3,其他临时性的函数
         为了绑定其他的this函数
         在不影响其他代码的前提下，保持代码的简洁
         .................................
         新增的对象字面量的方法
         1。成员速写  成员名和对象名相同时，刻意简写，只写一个就可以
         2.方法速写 对象中的方法可以省略冒号和function
         3.初始化对象时，属性名来自某个表达式的值，可以使用中括号表示他是通过计算来得到的

         object新增的api
         object.is()用来判断两个对象是否相等，和绝对等差不多，除了nan,和-0 +0；
         object.assign()用于混合对象，对前一个值进行改动，覆盖已有的值，增加没有的值，可以把第一个参数设置为空
         对象，就不会改变后面的值
         object.getownpropertynames()可以返回一个对象的属性名，先返回数字按照升序，在返回其他的，按照写的顺序
         object.setprototypeof()用来设置某个对象的隐式原型

         类：构造函数的语法糖
         传统的构造函数的问题
         1.属性和原型方法定义分离，降低了可读性
         2.原型成员可以被枚举
         3.默认情况下，构造函数可以被当作普通函数使用
         类的特点
         1.类的声明不会被提升，与let和const一样，存在暂时性死区
         2.类中的所有代码均在严格模式下执行
         3.类中的所有方法是不可以枚举的
         4。类中的所有方法无法被当作构造函数使用
         5.类的构造器必须用new来调用

         类的其他书写方式
         1.可计算的成员名
         2.getter和setter
         object.defineproperty可定义某个对象成员属性的读取和设置
         使用getter和setter控制的属性，不在原型上
         3.静态成员，使用static关键字，可以有方法和成员，使用构造函数直接调用

         字段初始化器
         使用static的字段初始化器，添加的是静态成员
         没有使用static的，添加的成员位于对象上
         尽头函数在字段初始化器的位置上指向当前对象

         类也可以写作表达式
         装饰器，实际上也是一个函数

         类的继承
         如果两个类A和B，如果可以描述为B是A，则A和B形成继承关系
         1.B继承自A
         2.A派生B
         3.B是A的子类
         4.A是B的父类
         如果A是B的父类，则B会自动拥有A中的所有实例成员
         新的关键字
         extends：继承用于类的定义
         super：直接当作函数调用，表示父类的构造函数
                当作对象调用，表示父类的原型
         注意：Es6要求如果定义了constructor，并且该类是子类，则必须在第一行
         手动调用父类构造函数
         如果子类不写constructor，会有默认的构造器，该构造器需要的参数和父类一值，并且自动调用父类构造器
         

         对象解构
         使用es6的一种语法规则，将数组或对象的某个属性提取到某个

         符号
         符号是es6新增加的一个数据类型，他通过使用函数symbol（符号名）来创建
         符号设计的初衷是为了给队形设置私有属性
         私有属性：只能对象内部使用，外面无法使用
         符号具有以下特点：
         没有字面量
         使用typeof得到的类型是symbol
         每次调用symbol函数得到的符号永远不相等，无论符号名是否相同
         符号可以作为对象的属性名存在，这种属性称为符号属性
         开发者可以通过精心设计，让这些属性无法通过常规方式被外界进行访问
         符号属性是不能枚举的，因此使用for in循环无法得到符号属性，object.keys也不行
         object.getownpropertyNames尽管可以得到无法枚举的属性，也无法得到符号属性
         es6新增加方法Object.getOwnPropertySymbols，可以读取符号
         符号无法被隐式转换，因此不能被用于数学运算，字符串拼接或其他隐式转换的场景，但符号可以显式
         转换为字符串，通过string构造函数进行转换即可

         共享符号
         根据某个符号名称（符号描述）能够得到同一个符号
         Symbol.for('符号名')

         知名符号 减少魔法，暴露内部实现
         1.Symbol.hasInstance
         该符号用于定义构造函数的静态成员，他将影响instanceof的判定
         obj instansof A等效于A[Symbol.hasInstance](obj)

         回顾事件循环
         js运行的环境称之为宿主环境
         执行栈：call stack，一个数据结构，用于存放各种函数的执行环境，每一个
         函数执行之前。他的相关信息会加入到执行栈，函数调用之前，创建执行环境，然后
         加入到执行栈，函数调用之后，销毁执行环境

         js引擎永远执行的式执行栈的最顶部

         异步函数：某些函数不会立即执行，需要等到某个时机到达后才会执行，这样的函数称之为异步函数，比如事件处理函数，
         一步函数的执行时机会被宿主环境限制

         浏览器的宿主环境中包含五个线程
         1.js线程，负责执行执行栈的最顶部的代码
         2.gui线程：负责渲染页面
         3.事件监听线程：负责监听各种事件
         4.计时线程：负责计时
         5.网络线程：负责网络通信

         当上面的线程发生了某些事，如果该线程发现，这件事情有处理程序，他会将该处理程序加入到一个叫
         事件队列的内存，当JS发现，执行栈中没有了任何内容后，会将事件队列的第一个函数
         加入到执行栈中执行
        宏任务（队列）：macrotask,计时器结束的回调，事件回调，http回调等大部分异步函数进入宏队列
        微任务（队列）：Mutationobserver，promise产生的回调进入微队列
        其中微任务优先执行

        事件和回调函数的缺陷
        我们习惯于使用传统的回调或事件处理来解决异步问题
        事件：某个对象的属性是一个函数，当发生某件事情的时候，运行该函数
        dom.onclick = function(){

        }
        回调：运行某个函数以实现某个功能的时候，传入一个函数作为参数，
        当发生某件事的时候，会运行该函数
        本质上。事件和回调并没有本质区别，只是函数放置的位置不同而已随着
        前端工程的越来越复杂，该模式不在适合
        目前，该模式主要存在两个问题：
        1.回调地狱，某个异步操作需要等待之前的异步操作完成，无论用回调还是事件，都会陷入不断的嵌套中
        2.异步之间的联系，某个异步操作要等待多个异步操作的结果，对这种联系的处理，
        会让代码的复杂度剧增

        异步处理的通用模型：
        es官方参考了大量的异步场景，总结出一套异步的通用模型，该模型可以覆盖几乎所有的异步场景
        甚至是同步场景
        值得注意的是。为了兼容旧系统，没有抛弃过去的做法，只是基于该模型推出一个全新的Api
        使用该Api可以使异步更加简洁优雅
        1.es6将一件可能发生异步操作的事情，分为两个阶段unsettled和settled
        unsettled未决阶段表示事情还在进行前期的处理，并没有通向结果的那件事
        settled：已决阶段，事情已经有了一个结果，不管这个结果是好是坏，整件事情无法逆转
        事情总是从未决阶段逐步发展到已决阶段，并且未决阶段拥有控制何时通向已决阶段的能力

        2.有三种状态：pending,resolved,rejected
        pending:挂起，处于未决阶段，表示还在挂起
        resolved:已处理，已决阶段的一种状态，表示整件事情已经出现了一个结果，并且可以按照正常逻辑进行下去
        rejected：已拒绝，已决阶段的一种状态，表示整件事情出现了结果，通常是一个错误
        无论是阶段还是状态都是不可逆的

        3.当事情到达已决阶段的时候，通常需要进行后续处理，不同的已决状态决定了不同的后续处理
        resolved:正常的已决状态，后续处理为thenable
        rejected：非正常的已决状态，后续处理为catchable
        后续处理有多个，因此会形成作业队列，按照顺序执行

        整个事情称之为一个承诺

        promise的基本使用
        const pro = new Promise（(resolve,reject)=>{
            //未决阶段的处理
            //通过调用resolve函数将promise推向已决阶段的resolved状态
            //通过调用reject函数将promise推向已决阶段的rejected状态
            //都只能传递一个参数，表示推向状态的数据
        }）
        pro.then(data=>{
            //这是thenable函数。如果promise是resolvd状态，该函数会立即执行
            //如果是未决状态，则会加入作业队列，等待resolve状态后执行
            //data为状态数据
        }，err=>{
            //这是catchable函数，如果当前的promise已经是rejected状态，该函数会立即执行
            //如果是未决阶段则会加入到作业队列等待状态执行
            //err为状态数据
        })

    ----------------------
    未决阶段的处理函数是同步的，会立即执行
    thenable和catchable函数是一步的，就算立即执行，也会加入到时间队列中等待执行，加入的队列是微队列
    pro.then可以只添加tnenable函数，pro.catch可以单独参加catchable函数
    在未决阶段的处理函数中，如果发生未捕获的错误，会将状态推向rejected
    一旦状态推向了已决，无法在对状态做出任何改变
    promise 没有消除回调，只是让回调变得可控

    promise的串联
    当后续的promise需要用到之前的promise处理结果的时候，需要promise的串联

    promise对象中，无论是then 方法还是catch方法，他们都具有返回值，返回值是一个全新的promise对象，他的状态满足下列规则
    1.如果当前的promise状态是未决的，得到的新的promise是挂起的状态
    2.如果当前的promise状态是已决的，会运行影响后续函数，并将后续函数的处理结果返回值作为resolved状态的数据
    应用在新的promise函数中。
    
    后续的promise一定会等到前面的promise有了后续处理结果后，才会变成已决的状态
    如果前面的promise后续处理返回的是一个promise，则返回的新的promise状态和后续的状态保持一致
    
    其他的Api
    finally注册一个后续处理函数，没有参数的，当promise已决的时候运行该参数
    构造函数成员（静态成员）
    resolve（数据）该方法返回一个resolved状态的promise，传递的数据作为状态数据
    特殊情况，如果传递的数据是promise，则直接返回promise对象
    reject（数据）：该方法返回一个rejected状态的promise，传递的数据作为状态数据
    all（传递一个数组），该方法返回一个新的promise对象，所有的对象都成功的时候才会触发成功
    race（传递一个数组），当其中任何一个成功或失败的时候就会返回该对象

    fetch api概述
    xmlhttpruquest的问题：
    1.所有的功能全部集中在同一个对象上，容易书写出混不易维护的代码
    2.采用传统的事件驱动模式，无法适配新的promise api
    fetch api 的特点：
    1.并非取代ajax，而是对ajax传统api的改进
    2.精细的功能分割：头部信息，请求信息，响应信息等均分部到不同的对象，更利于处理
    各种复杂的ajax场景
    3.使用promise api，更有利于异步代码的书写
    4.并不是es6的内容，属于HTML5新增的web api
    5.需要掌握网络通信的知识。

    基本使用
    该函数有两个参数
    1.必填，字符串，请求地址
    2.选填，对象，请求配置
    请求配置对象
    1.method：字符串，请求方法，默认为get
    2.headers:对象，请求头信息
    3.body：请求体内容，必须匹配请求头中的content-type
    4.mode:字符串，请求模式
    cors:默认值，会在请求头中加上origin,和referer

    返回值：
    fetch函数返回的是一个promise对象，当收到服务器的结果后，promise进入resolved状态，状态数据为response对象
    当网络发生错误的时候，promise进入rejected状态，状态数据为错误信息
    response对象：
    OK：boolean当响应信息码在200-299之间时为true，其他为false
    status：number，响应的状态码
    text（）：用于处理文本格式的Ajax响应
    blob（）：用于处理二进制文件格式
    json():用于处理json格式
    redirect（）：用于处理重定向

    request对象
    除了使用基本的fetch方法，还可以通过创建一个request对象来完成请求
    new Request(url,配置)
    注意点：尽量保证每次请求都是一个新的request对象
    response同上
    headers对象
    在request和response对象内部，会将传递的请求头对象，转换为headers
    headers对象中的方法：
    has(key):检查请求头中是否存在指定的key值
    get(key):得到请求头中对应的key值
    set（key,value):修改对应的键值对
    append（key,value):添加对应的键值对
    keys()得到所有的请求头健的集合
    values()得到所有的请求头中的值的集合
    entries()得到所有的请求头键值对的集合

    文件上传
    流程：1.客户端将文件数据发送给服务器
    2.服务器保存上传的文件数据到服务器端
    3.服务器响应给客户端一个文件访问地址

    键的名称（表单域名称）：imagefile

    请求方法：post
    请求的表单格式：multipart/form-data
    请求体中必须包含一个键值对，键的名称是服务器要求的名称，值是文件数据

    HTML5中,js仍然无法随意的获取文件数据，但是可以获取到Input元素中被用户选中的文件数据
    可以利用html5提供的formdata构造函数来创建请求体

    迭代器：
    1.什么是迭代 从一个数据集合中按照一定的顺序，不断取出数据的过程
    2.迭代和遍历的区别：
    迭代强调的是依次取数据，并不保证取多少，也不保证把所有的数据取玩
    遍历强调的是把整个数据依次全部取出
    3.迭代器
    对迭代过程的封装，在不同的语言中具有不同的变现形式，通常为对象
    4。迭代模式：一种设计模式，用于统一迭代过程，并规范了迭代器的规格
    迭代器应该具有得到下一个数据的能力
    迭代器应该具有判断是否还有后续数据的能力

    js中的迭代器：
    js规定，如果一个对象具有next方法，并且该方法返回一个对象，该对象的格式如下：
    {value:值，done:是否迭代完成}
    则认为该对象是一个迭代器
    含义：
    next方法：用于得到下一个数据
    返回的对象：
    value：下一个数据的值
    done :boolean 是否迭代完成

    可迭代协议：es6规定如果一个对象具有知名符号属性symbol.iterator,并且属性值是一个迭代器创建函数，则该对象是可迭代的
    for of 循环
    for(const item in iterable){
        iterable可迭代对象
        item每次迭代得到的数据
    }
    展开运算符可以作用于可迭代对象，这样就可以轻松的将可迭代对象转化为数组
    





     





    
    
    
    
    
    -->
    
</body>
</html>